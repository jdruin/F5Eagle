###############################################################################
#
# redefine.eagle --
#
# Extensible Adaptable Generalized Logic Engine (Eagle)
#
# Copyright (c) 2007-2012 by Joe Mistachkin.  All rights reserved.
#
# See the file "license.terms" for information on usage and redistribution of
# this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: $
#
###############################################################################

source [file join [file normalize [file dirname [info script]]] prologue.eagle]

###############################################################################

#
# NOTE: Instead of using [debug restore], this test could use interpreter
#       isolation (i.e. via the -isolationLevel option).
#
runTest {test redefine-1.1 {redefine set while script is pending} -setup {
  unset -nocomplain x
} -body {
  list [set x 1] [set x [proc set args "return {GOOD $x}"]] $x
} -cleanup {
  unset x

  #
  # NOTE: Now, remove the set procedure and restore the core
  #       [set] command.
  #
  rename -kind procedure set ""; debug restore

  #
  # NOTE: *SPECIAL* If an "optional" command (i.e. as recognized by the
  #       test suite) was not present before [debug restore], remove it
  #       now.
  #
  if {![haveConstraint command.callback]} then {
    catch {rename callback ""}
  }

  if {![haveConstraint command.library]} then {
    catch {rename library ""}
  }

  if {![haveConstraint command.object]} then {
    catch {rename object ""}
  }

  if {![haveConstraint command.socket]} then {
    catch {rename socket ""}
  }

  if {![haveConstraint command.sql]} then {
    catch {rename sql ""}
  }

  if {![haveConstraint command.tcl]} then {
    catch {rename tcl ""}
  }

  if {![haveConstraint command.xml]} then {
    catch {rename xml ""}
  }
} -constraints {eagle} -result {1 {GOOD 1} 1}}

###############################################################################

if {[isEagle]} then {
  proc getSubCommandsAndCommand { interp name hidden create {varName ""} } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    if {[string length $varName] > 0} then {
      upvar 1 $varName command
    }

    set command null; set error null

    set code [$interpreter -alias \
        GetIdentifier [expr {$hidden ? "HiddenCommand" : "Command"}] \
        $name null Default command error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $command +NoDispose; # NOTE: Not owned.
    set subCommands [$command -alias SubCommands]

    if {$create && ![isObjectHandle $subCommands]} then {
      set subCommands [object create -alias EnsembleDictionary]
      $command SubCommands $subCommands
    }

    return $subCommands
  }

  proc getSubCommands { interp name hidden allowed create } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set command null; set error null

    set code [$interpreter -alias \
        GetIdentifier [expr {$hidden ? "HiddenCommand" : "Command"}] \
        $name null Default command error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $command +NoDispose; # NOTE: Not owned.

    if {[string length $allowed] == 0} then {
      set subCommands [$command -alias SubCommands]

      if {$create && ![isObjectHandle $subCommands]} then {
        set subCommands [object create -alias EnsembleDictionary]
        $command SubCommands $subCommands
      }
    } elseif {$allowed} then {
      set subCommands [$command -alias AllowedSubCommands]

      if {$create && ![isObjectHandle $subCommands]} then {
        set subCommands [object create -alias EnsembleDictionary]
        $command AllowedSubCommands $subCommands
      }
    } else {
      set subCommands [$command -alias DisallowedSubCommands]

      if {$create && ![isObjectHandle $subCommands]} then {
        set subCommands [object create -alias EnsembleDictionary]
        $command DisallowedSubCommands $subCommands
      }
    }

    return $subCommands
  }

  proc getCommand { interp name hidden } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set command null; set error null

    set code [$interpreter -alias \
        GetIdentifier [expr {$hidden ? "HiddenCommand" : "Command"}] \
        $name null Default command error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $command +NoDispose; # NOTE: Not owned.
    return $command
  }

  proc createSubCommand {
          viaTest name command scriptCommand execute useIExecute
          useExecuteArguments } {
    #
    # NOTE: Use the dedicated test class if requested -OR- if we
    #       have no choice (i.e. because they are using a feature
    #       not supported by the core class).
    #
    if {$viaTest || $useIExecute} then {
      set subCommand [object create -alias \
          Eagle._Tests.Default+SubCommand $name $command null null None \
          $scriptCommand $execute $useIExecute $useExecuteArguments]
    } else {
      set subCommand [object invoke -alias -flags +NonPublic \
          Eagle._Components.Private.ScriptOps NewCommandSubCommand \
          $name null $command $scriptCommand [expr {$useExecuteArguments ? \
          "UseExecuteArguments" : "None"}]]
    }

    return $subCommand
  }

  proc getScopeFrame { interp name } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set frame null

    set code [$interpreter -flags +NonPublic GetScopeCallFrame \
        $name Default false false frame error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $frame +NoDispose; # NOTE: Not owned.
    return $frame
  }

  proc getNamespaceV1 { interp name } {
    set error null

    set namespace [object invoke -flags +NonPublic \
        Eagle._Components.Private.NamespaceOps Lookup $interp $name false \
        false error]

    if {![isObjectHandle $namespace]} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $namespace +NoDispose; # NOTE: Not owned.
    return $namespace
  }

  proc getNamespaceV2 { interp name } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set namespace null; set error null

    set code [object invoke \
        $interpreter LookupNamespace "" false namespace error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $namespace +NoDispose; # NOTE: Not owned.
    return $namespace
  }

  proc createNamespace { interp namespaceData } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set namespace null; set error null

    set code [object invoke \
        $interpreter CreateNamespace $namespaceData null true \
        namespace error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $namespace +NoDispose; # NOTE: Not owned.
    return $namespace
  }

  proc getIExecute { interp name } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set execute null; set error null

    set code [$interpreter -flags +NonPublic GetIExecuteViaResolvers \
        UseAll $name null Default execute error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $execute +NoDispose; # NOTE: Not owned.
    return $execute
  }

  proc getGlobalVariable { interp name } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set flags GlobalOnly; set variable null; set error null

    set code [$interpreter -flags +NonPublic \
        GetVariableViaResolversWithSplit $name flags variable error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    object flags $variable +NoDispose; # NOTE: Not owned.
    return $variable
  }

  proc setResolver { interp resolve } {
    set interpreter null; set error null

    set code [object invoke -alias \
        Value GetInterpreter "" $interp Default interpreter error]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $error]
    }

    set result null
    set code [$interpreter AddResolver $resolve null Default result]

    if {$code ne "Ok"} then {
      error [getStringFromObjectHandle $result]
    }
  }
}

###############################################################################

runTest {test redefine-2.1 {remove core library sub-command} -body {
  set interp [interp create]
  set subCommands [getSubCommandsAndCommand $interp string false false]

  $subCommands Remove length

  set code [catch {
    interp eval $interp {string length foo}
  } result]

  list $code $result
} -cleanup {
  catch {object dispose $subCommand}
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain subCommands interp
} -constraints {eagle command.object} -match regexp -result \
{^1 \{bad option "length": .*\}$}}

###############################################################################

runTest {test redefine-2.2 {add core library sub-command (test)} -body {
  set interp [interp create]
  set subCommands [getSubCommandsAndCommand $interp string false false command]

  set list [object create -alias StringList]
  $list Add return; $list Add foo

  set subCommand [createSubCommand \
      true foo $command $list null false false]

  $subCommands Add foo $subCommand

  set code [catch {
    interp eval $interp {string foo}
  } result]

  list $code $result [$subCommand -flags +NonPublic executeCount]
} -cleanup {
  catch {object dispose $subCommand}
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain subCommand command subCommands interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString} -result {0 foo 1}}

###############################################################################

runTest {test redefine-2.3 {modify core library sub-command (test)} -body {
  set interp [interp create]
  set subCommands [getSubCommandsAndCommand $interp string false false command]

  interp eval $interp {
    proc string_length { args } {
      if {[llength $args] != 3} then {
        error {wrong # args: should be "string length string"}
      }
      set value [lindex $args end]
      set string [object create -alias String $value]
      return [expr {42 + [$string Length]}]
    }
  }

  set list [object create -alias StringList]
  $list Add string_length

  set subCommand [createSubCommand \
      true length $command $list null false true]

  $subCommands Item length $subCommand

  set code [catch {
    interp eval $interp {string length foo}
  } result]

  list $code $result [$subCommand -flags +NonPublic executeCount]
} -cleanup {
  catch {object dispose $subCommand}
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain subCommand command subCommands interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString} -result {0 45 1}}

###############################################################################

runTest {test redefine-2.4 {wrap core library sub-command (test)} -body {
  set interp [interp create]
  set subCommands [getSubCommandsAndCommand $interp string false false command]

  set subCommand [createSubCommand \
      true length $command null $command true false]

  $subCommands Item length $subCommand

  set code [catch {
    interp eval $interp {string length foo}
  } result]

  list $code $result [$subCommand -flags +NonPublic executeCount]
} -cleanup {
  catch {object dispose $subCommand}
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain subCommand command subCommands interp
} -constraints {eagle command.object compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString} -result {0 3 1}}

###############################################################################

runTest {test redefine-2.5 {add core library sub-command (core)} -body {
  set interp [interp create]
  set subCommands [getSubCommandsAndCommand $interp string false false command]

  set list [object create -alias StringList]
  $list Add return; $list Add foo

  set subCommand [createSubCommand \
      false foo $command $list null false false]

  $subCommands Add foo $subCommand

  set code [catch {
    interp eval $interp {string foo}
  } result]

  list $code $result
} -cleanup {
  catch {object dispose $subCommand}
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain subCommand command subCommands interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString} -result {0 foo}}

###############################################################################

runTest {test redefine-2.6 {modify core library sub-command (core)} -body {
  set interp [interp create]
  set subCommands [getSubCommandsAndCommand $interp string false false command]

  interp eval $interp {
    proc string_length { args } {
      if {[llength $args] != 3} then {
        error {wrong # args: should be "string length string"}
      }
      set value [lindex $args end]
      set string [object create -alias String $value]
      return [expr {42 + [$string Length]}]
    }
  }

  set list [object create -alias StringList]
  $list Add string_length

  set subCommand [createSubCommand \
      false length $command $list null false true]

  $subCommands Item length $subCommand

  set code [catch {
    interp eval $interp {string length foo}
  } result]

  list $code $result
} -cleanup {
  catch {object dispose $subCommand}
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain subCommand command subCommands interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString} -result {0 45}}

###############################################################################

runTest {test redefine-2.7 {clear core library sub-commands (core)} -body {
  set interp [interp create]
  set subCommands [getSubCommandsAndCommand $interp string false false command]

  $subCommands Clear

  set code [catch {
    interp eval $interp {string length foo}
  } result]

  list $code $result
} -cleanup {
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain subCommand command subCommands interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString} -result \
{1 {bad option "length"}}}

###############################################################################

runTest {test redefine-3.1 {remove core library sub-command (interp)} -body {
  set interp [interp create]

  interp subcommand -flags ForceDelete -- \
      $interp string length ""

  set code [catch {
    interp eval $interp {string length foo}
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code interp
} -constraints {eagle} -match regexp -result {^1 \{bad option "length": .*\}$}}

###############################################################################

runTest {test redefine-3.2 {add core library sub-command (interp)} -body {
  set interp [interp create]
  interp subcommand $interp string foo "return foo"

  set code [catch {
    interp eval $interp {string foo}
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code interp
} -constraints {eagle} -result {0 foo}}

###############################################################################

runTest {test redefine-3.3 {modify core library sub-command (interp)} -body {
  set interp [interp create]

  interp subcommand -flags UseExecuteArguments -- \
      $interp string length string_length

  interp eval $interp {
    proc string_length { args } {
      if {[llength $args] != 3} then {
        error {wrong # args: should be "string length string"}
      }
      set value [lindex $args end]
      set string [object create -alias String $value]
      return [expr {42 + [$string Length]}]
    }
  }

  set code [catch {
    interp eval $interp {string length foo}
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code interp
} -constraints {eagle} -result {0 45}}

###############################################################################

runTest {test redefine-3.4 {reset core library sub-command (interp)} -body {
  set interp [interp create]

  interp subcommand -flags UseExecuteArguments -- \
      $interp string length string_length

  interp eval $interp {
    proc string_length { args } {
      if {[llength $args] != 3} then {
        error {wrong # args: should be "string length string"}
      }
      set value [lindex $args end]
      set string [object create -alias String $value]
      return [expr {42 + [$string Length]}]
    }
  }

  set code(1) [catch {
    interp eval $interp {string length foo}
  } result(1)]

  interp subcommand $interp string length ""

  set code(2) [catch {
    interp eval $interp {string length foo}
  } result(2)]

  list $code(1) $result(1) $code(2) $result(2)
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code interp
} -constraints {eagle} -result {0 45 0 3}}

###############################################################################

runTest {test redefine-3.5 {restore core library sub-command (interp)} -body {
  set interp [interp create]

  interp subcommand -flags ForceDelete -- \
      $interp string length ""

  set code(1) [catch {
    interp eval $interp {string length foo}
  } result(1)]

  interp subcommand -flags ForceReset -- \
      $interp string length ""

  set code(2) [catch {
    interp eval $interp {string length foo}
  } result(2)]

  list $code(1) $result(1) $code(2) $result(2)
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code interp
} -constraints {eagle} -match regexp -result \
{^1 \{bad option "length": .*\} 0 3$}}

###############################################################################

runTest {test redefine-3.6 {query core library sub-command (interp)} -body {
  set interp [interp create]

  set result(1) [interp subcommand $interp string length]

  interp subcommand $interp string length string_length

  set result(2) [interp subcommand $interp string length]

  interp subcommand $interp string length ""

  set result(3) [interp subcommand $interp string length]

  interp subcommand -flags ForceDelete -- \
      $interp string length ""

  set code(4) [catch {
    interp subcommand $interp string length
  } result(4)]

  set code(5) [catch {
    interp subcommand -flags "ForceQuery NoComplain" -- \
        $interp string length ""
  } result(5)]

  list $result(1) $result(2) $result(3) $code(4) $result(4) $code(5) $result(5)
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code interp
} -constraints {eagle} -result {{} {Eagle._SubCommands.Command length} {} 1\
{can't query sub-command: doesn't exist} 0 {}}}

###############################################################################

runTest {test redefine-4.1 {remove plugin sub-command} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false ""]

      $subCommands Remove example3

      class12 example3
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain interp
} -constraints {eagle command.object compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -match regexp -result \
{^1 \{bad option "example3": .*\}$}}

###############################################################################

runTest {test redefine-4.2 {add plugin sub-command (test)} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  interp eval $interp \
      [list proc createSubCommand \
      [info args createSubCommand] \
      [info body createSubCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false command]

      set list [object create -alias StringList]
      $list Add return; $list Add foo

      set subCommand [createSubCommand \
          true example4 $command $list null false false]

      $subCommands Add example4 $subCommand

      list [class12 example4] \
          [$subCommand -flags +NonPublic executeCount]
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -result {0 {foo 1}}}

###############################################################################

runTest {test redefine-4.3 {modify plugin sub-command (test)} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  interp eval $interp \
      [list proc createSubCommand \
      [info args createSubCommand] \
      [info body createSubCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false command]

      proc class12_example4 { args } {
        if {[llength $args] != 2} then {
          error {wrong # args: should be "class12 example4"}
        }
        return "not a number"
      }

      set list [object create -alias StringList]
      $list Add class12_example4

      set subCommand [createSubCommand \
          true example4 $command $list null false true]

      $subCommands Item example4 $subCommand

      list [class12 example4] \
          [$subCommand -flags +NonPublic executeCount]
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -result {0 {{not a number} 1}}}

###############################################################################

runTest {test redefine-4.4 {wrap plugin sub-command (test)} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  interp eval $interp \
      [list proc createSubCommand \
      [info args createSubCommand] \
      [info body createSubCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false command]

      set subCommand [createSubCommand \
          true example2 $command null $command true false]

      $subCommands Item example2 $subCommand

      list [class12 example2] \
          [$subCommand -flags +NonPublic executeCount]
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain interp
} -constraints {eagle command.object compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -match regexp -result {^0 \{\d+ 1\}$}}

###############################################################################

runTest {test redefine-4.5 {wrap plugin nested sub-command (test)} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  interp eval $interp \
      [list proc createSubCommand \
      [info args createSubCommand] \
      [info body createSubCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false command]

      set oldSubCommand [$subCommands Item example3]
      object flags $oldSubCommand +NoDispose; # NOTE: Not owned.

      set newSubCommand [createSubCommand \
          true example3 $command null $oldSubCommand true false]

      $subCommands Item example3 $newSubCommand

      list [class12 example3] \
          [$newSubCommand -flags +NonPublic executeCount]
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain interp
} -constraints {eagle command.object compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -match regexp -result {^0 \{\d+ 1\}$}}

###############################################################################

runTest {test redefine-4.6 {add plugin sub-command (core)} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  interp eval $interp \
      [list proc createSubCommand \
      [info args createSubCommand] \
      [info body createSubCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false command]

      set list [object create -alias StringList]
      $list Add return; $list Add foo

      set subCommand [createSubCommand \
          false example3 $command $list null false false]

      $subCommands Add foo $subCommand

      class12 example3
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -match regexp -result {^0 \d+$}}

###############################################################################

runTest {test redefine-4.7 {modify plugin sub-command (core)} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  interp eval $interp \
      [list proc createSubCommand \
      [info args createSubCommand] \
      [info body createSubCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false command]

      proc class12_example3 { args } {
        if {[llength $args] != 2} then {
          error {wrong # args: should be "class12 example3"}
        }
        return "something important"
      }

      set list [object create -alias StringList]
      $list Add class12_example3

      set subCommand [createSubCommand \
          false example3 $command $list null false true]

      $subCommands Item length $subCommand

      class12 example3
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -match regexp -result {^0 \d+$}}

###############################################################################

runTest {test redefine-4.8 {clear plugin sub-commands (core)} -body {
  set interp [interp create -isolated]

  interp eval $interp \
      [list proc getSubCommandsAndCommand \
      [info args getSubCommandsAndCommand] \
      [info body getSubCommandsAndCommand]]

  set code [catch {
    interp eval $interp {
      package require Sample.Class3

      set subCommands [getSubCommandsAndCommand \
          "" class12 false false command]

      $subCommands Clear

      set code [catch {class12 example3} result]; list $code $result
    }
  } result]

  list $code $result
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code list
  unset -nocomplain interp
} -constraints {eagle command.object monoBug30 compile.TEST\
member_Eagle._Tests.Default.SubCommand.ToString compile.ISOLATED_INTERPRETERS\
file_Plugin.dll strongName.official} -result {0 {1 {bad option "example3"}}}}

###############################################################################

if {[isEagle]} then {
  rename createSubCommand ""
  rename getSubCommandsAndCommand ""
}

###############################################################################

runTest {test resolver-1.1 {custom IResolve.GetVariableFrame} -body {
  set interp(1) [interp create]

  interp eval $interp(1) {
    #
    # HACK: Work around having the Badge plugin loaded by removing
    #       any pre-existing [flags] command, thus preventing command
    #       name collisions with the aliased "flags" parameter to the
    #       IResolve.GetVariableFrame interface method.
    #
    catch {rename flags ""}

    scope create -open -- resolver-1.1; set x 1234
  }

  set script {
    if {[isObjectHandle varName]} then {
      if {[varName ToString] eq "x"} then {
        return true
      } elseif {[varName ToString] eq "::::bad1"} then {
        error "bad variable frame"
      }
    }

    return false
  }

  set frame [getScopeFrame $interp(1) resolver-1.1]

  set interp(2) [interp create]

  set resolve [object create -alias Eagle._Tests.Default+Resolve \
      $interp(1) $interp(2) $script $frame null null null Default]

  setResolver $interp(2) $resolve

  set code(1) [catch {
    interp eval $interp(2) {
      set ::::good1
    }
  } result(1)]

  set code(2) [catch {
    interp eval $interp(2) {
      set ::::bad1
    }
  } result(2)]

  set code(3) [catch {
    interp eval $interp(2) {
      set x
    }
  } result(3)]

  list $code(1) $result(1) $code(2) $result(2) $code(3) $result(3)
} -cleanup {
  catch {interp delete $interp(2)}
  catch {interp delete $interp(1)}

  catch {object dispose $frame}

  unset -nocomplain code result script frame resolve interp
} -constraints {eagle command.object compile.TEST\
member_Eagle._Tests.Default.Resolve.ToString} -result {1 {can't read\
"::::good1": no such variable} 1 {can't read "::::bad1": no such variable} 0\
1234}}

###############################################################################

runTest {test resolver-1.2 {custom IResolve.GetCurrentNamespace} -body {
  set interp(1) [interp create -namespaces]

  if {[haveConstraint quiet]} then {
    interp eval $interp(1) {
      object invoke Interpreter.GetActive Quiet true

      object invoke -flags +NonPublic Interpreter.GetActive \
          SetNoBackgroundError true
    }
  }

  interp eval $interp(1) {
    #
    # HACK: Work around having the Badge plugin loaded by removing
    #       any pre-existing [flags] command, thus preventing command
    #       name collisions with the aliased "flags" parameter to the
    #       IResolve.GetVariableFrame interface method.
    #
    catch {rename flags ""}

    namespace eval ::one::two::three {
      variable x 54321
    }
  }

  set script {
    if {[isObjectHandle frame]} then {
      set frame frame
    } else {
      set frame [targetInterpreter -alias -flags +NonPublic \
          -objectflags +NoDispose CurrentFrame]
    }

    try {
      if {[isObjectHandle $frame]} then {
        if {[$frame Name] eq [list "namespace eval" ::good1]} then {
          return true
        } elseif {[$frame Name] eq [list "namespace eval" ::bad1]} then {
          error "bad namespace"
        }
      }

      return false
    } finally {
      catch {object dispose $frame}
    }
  }

  set interp(2) [interp create -namespaces]

  interp eval $interp(2) {
    namespace eval ::::good1 {}
    namespace eval ::::bad1 {}
    namespace eval ::::x {}
  }

  set namespace [getNamespaceV1 $interp(1) ::one::two::three]

  set resolve [object create -alias Eagle._Tests.Default+Resolve \
      $interp(1) $interp(2) $script null $namespace null null Default]

  setResolver $interp(2) $resolve

  set code(1) [catch {
    interp eval $interp(2) {
      namespace eval ::::good1 {
        info vars
      }
    }
  } result(1)]

  set code(2) [catch {
    interp eval $interp(2) {
      namespace eval ::::bad1 {
        info vars
      }
    }
  } result(2)]

  set code(3) [catch {
    interp eval $interp(2) {
      namespace eval ::::x {
        info vars
      }
    }
  } result(3)]

  list $code(1) $result(1) $code(2) $result(2) $code(3) $result(3)
} -cleanup {
  catch {interp delete $interp(2)}
  catch {interp delete $interp(1)}

  catch {object dispose $namespace}

  unset -nocomplain code result script namespace resolve interp
} -constraints {eagle command.object compile.TEST\
namespaces.available member_Eagle._Tests.Default.Resolve.ToString} -result {0 x\
0 {} 0 {}}}

###############################################################################

runTest {test resolver-1.3 {custom IResolve.GetIExecute} -body {
  set interp(1) [interp create]

  interp eval $interp(1) {
    proc resolver-1.3 {} {
      return [object invoke Interpreter.GetActive Id]
    }
  }

  set script {
    if {[isObjectHandle name]} then {
      if {[name ToString] eq "::::good1"} then {
        return true
      } elseif {[name ToString] eq "::::bad1"} then {
        error "bad execute"
      }
    }

    return false
  }

  set interp(2) [interp create]

  interp eval $interp(2) {
    rename xml ""
  }

  set execute [getIExecute $interp(1) resolver-1.3]

  set resolve [object create -alias Eagle._Tests.Default+Resolve \
      $interp(1) $interp(2) $script null null $execute null Default]

  setResolver $interp(2) $resolve

  set code(1) [catch {
    interp eval $interp(2) {
      ::::good1
    }
  } result(1)]

  set code(2) [catch {
    interp eval $interp(2) {
      ::::bad1
    }
  } result(2)]

  set code(3) [catch {
    interp eval $interp(2) {
      x
    }
  } result(3)]

  list $code(1) $result(1) $code(2) $result(2) $code(3) $result(3)
} -cleanup {
  catch {interp delete $interp(2)}
  catch {interp delete $interp(1)}

  catch {object dispose $execute}

  unset -nocomplain code result script execute resolve interp
} -constraints {eagle command.object compile.TEST\
member_Eagle._Tests.Default.Resolve.ToString} -match regexp -result {^0 \d+ 1\
\{invalid command name "::::bad1"\} 1 \{invalid command name "x"\}$}}

###############################################################################

runTest {test resolver-1.4 {custom IResolve.GetVariable} -body {
  set interp(1) [interp create]

  interp eval $interp(1) {
    set xyz 12345
  }

  set script {
    if {[isObjectHandle varName]} then {
      if {[varName ToString] eq "::::good1"} then {
        return true
      } elseif {[varName ToString] eq "::::bad1"} then {
        error "bad variable"
      }
    }

    return false
  }

  set interp(2) [interp create]

  set variable [getGlobalVariable $interp(1) xyz]

  set resolve [object create -alias Eagle._Tests.Default+Resolve \
      $interp(1) $interp(2) $script null null null $variable Default]

  setResolver $interp(2) $resolve

  set code(1) [catch {
    interp eval $interp(2) {
      set ::::good1
    }
  } result(1)]

  set code(2) [catch {
    interp eval $interp(2) {
      set ::::bad1
    }
  } result(2)]

  set code(3) [catch {
    interp eval $interp(2) {
      set x
    }
  } result(3)]

  list $code(1) $result(1) $code(2) $result(2) $code(3) $result(3)
} -cleanup {
  catch {interp delete $interp(2)}
  catch {interp delete $interp(1)}

  catch {object dispose $variable}

  unset -nocomplain code result script variable resolve interp
} -constraints {eagle command.object compile.TEST\
member_Eagle._Tests.Default.Resolve.ToString} -result {0 12345 1 {can't read\
"::::bad1": no such variable} 1 {can't read "x": no such variable}}}

###############################################################################

if {[isEagle]} then {
  rename getNamespaceV1 ""
  rename getScopeFrame ""
}

###############################################################################

runTest {test resolver-1.50 {isolated IResolve} -body {
  set interp(2) [interp create -isolated -namespaces]

  set resolve [object create -alias Eagle._Tests.Default+Resolve \
      null $interp(2) null null null null null Default]

  setResolver $interp(2) $resolve

  set code(1) [catch {
    interp eval $interp(2) {
      namespace eval ::one {
        variable xyz 9999

        proc two {} {
          variable xyz

          set result [list]

          foreach varName [lsort [info vars]] {
            lappend result $varName [set $varName]
          }

          return $result
        }

        two
      }
    }
  } result(1)]

  list $code(1) $result(1) [getStringFromObjectHandle $resolve]
} -cleanup {
  catch {interp delete $interp(2)}

  unset -nocomplain code result resolve interp
} -constraints {eagle command.object compile.TEST compile.APPDOMAINS\
compile.ISOLATED_INTERPRETERS namespaces.available\
member_Eagle._Tests.Default.Resolve.ToString} -result \
{0 {result {} xyz 9999} {28 32 15 20}}}

###############################################################################

if {[isEagle]} then {
  rename setResolver ""
}

###############################################################################

runTest {test resolver-1.51 {per-namespace IResolve} -body {
  set interp(1) [interp create]

  interp eval $interp(1) {
    set xyz 12345

    set methodNames [list]
    set executeNames [list]
    set variableNames [list]
  }

  set execute [getIExecute $interp(1) incr]
  set variable [getGlobalVariable $interp(1) xyz]

  set interp(2) [interp create -namespaces]

  interp eval $interp(2) {
    set x 0
  }

  set globalNamespace [getNamespaceV2 $interp(2) ""]

  set script {
    set methodName [methodName ToString]
    lappend methodNames $methodName
    switch -exact -- $methodName {
      GetVariableFrame {
        return true
      }
      GetCurrentNamespace {
        return true
      }
      GetIExecute {
        set executeName [name ToString]
        lappend executeNames $executeName
        if {$executeName eq "otherincr"} then {
          return true
        }
      }
      GetVariable {
        set variableName [varName ToString]
        lappend variableNames $variableName
        if {$variableName eq "otherxyz"} then {
          return true
        }
      }
      default {
        error "unsupported method name"
      }
    }

    return false
  }

  set resolve [object create -alias Eagle._Tests.Default+Resolve \
      $interp(1) $interp(2) $script null null $execute $variable \
      {Default AlwaysUseNamespaceFrame}]

  set namespaceData [object create \
      NamespaceData special null $interp(2) $globalNamespace \
      $resolve null null]

  set namespace [createNamespace $interp(2) $namespaceData]
  object invoke -flags +NonPublic $resolve namespace $namespace; # field

  set code(1) [catch {
    interp eval $interp(2) {
      namespace eval ::special {
        otherincr ::x 111
      }
    }
  } result(1)]

  set code(2) [catch {
    interp eval $interp(2) {
      ::special::otherincr x 222
    }
  } result(2)]

  set code(3) [catch {
    interp eval $interp(2) {
      set ::special::otherxyz 999
    }
  } result(3)]

  set code(4) [catch {
    interp eval $interp(1) {
      list $methodNames $executeNames $variableNames $xyz
    }
  } result(4)]

  set code(5) [catch {
    interp eval $interp(1) {
      info exists x
    }
  } result(5)]

  set code(6) [catch {
    interp eval $interp(2) {
      set x
    }
  } result(6)]

  list $code(1) $result(1) $code(2) $result(2) $code(3) $result(3) \
      $code(4) $result(4) $code(5) $result(5) $code(6) $result(6) \
      [getStringFromObjectHandle $resolve]
} -cleanup {
  catch {interp delete $interp(2)}
  catch {interp delete $interp(1)}

  catch {object dispose $execute}
  catch {object dispose $variable}
  catch {object dispose $globalNamespace}
  catch {object dispose $namespace}

  unset -nocomplain code result script execute variable resolve interp \
      globalNamespace namespaceData namespace
} -constraints {eagle command.object compile.TEST namespaces.available\
member_Eagle._Tests.Default.Resolve.ToString} -result {0 111 0 333 0 999 0\
{{GetIExecute GetIExecute GetVariable} {otherincr otherincr} otherxyz 999} 0 0\
0 333 {2 0 2 1}}}

###############################################################################

if {[isEagle]} then {
  rename getGlobalVariable ""
  rename getIExecute ""
  rename getNamespaceV2 ""
  rename createNamespace ""
}

###############################################################################

runTest {test safe-1.90 {add to built-in "safe" [info] policy} -body {
  set interp [interp create -safe]
  set subCommands [getSubCommands $interp info true true false]

  set code(1) [catch {
    interp eval $interp {
      info cmdcount
    }
  } result(1)]

  $subCommands Add cmdcount null

  set code(2) [catch {
    interp eval $interp {
      info cmdcount
    }
  } result(2)]

  list $code(1) $result(1) $code(2) $result(2)
} -cleanup {
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain subCommands interp
} -constraints {eagle command.object} -match regexp -result {^1 \{permission\
denied: safe interpreter cannot use command "info cmdcount"\} 0 \d+$}}

###############################################################################

runTest {test safe-1.91 {remove from built-in "safe" [info] policy} -body {
  set interp [interp create -safe]
  set subCommands [getSubCommands $interp info true true false]

  set code(1) [catch {
    interp eval $interp {
      info level
    }
  } result(1)]

  $subCommands Remove level

  set code(2) [catch {
    interp eval $interp {
      info level
    }
  } result(2)]

  list $code(1) $result(1) $code(2) $result(2)
} -cleanup {
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain subCommands interp
} -constraints {eagle command.object} -result {0 0 1 {permission denied: safe\
interpreter cannot use command "info level"}}}

###############################################################################

runTest {test safe-1.92 {remove from built-in "safe" [package] policy} -body {
  set interp [interp create -safe]
  set subCommands [getSubCommands $interp package true false false]

  set code(1) [catch {
    interp eval $interp {
      package reset
    }
  } result(1)]

  $subCommands Remove reset

  set code(2) [catch {
    interp eval $interp {
      package reset
    }
  } result(2)]

  list $code(1) $result(1) $code(2) $result(2)
} -cleanup {
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain subCommands interp
} -constraints {eagle command.object} -result {1 {permission denied: safe\
interpreter cannot use command "package reset"} 0 {}}}

###############################################################################

runTest {test safe-1.93 {add to built-in "safe" [package] policy} -body {
  set interp [interp create -safe]
  set subCommands [getSubCommands $interp package true false false]

  set code(1) [catch {
    interp eval $interp {
      package require Eagle
    }
  } result(1)]

  $subCommands Add require null

  set code(2) [catch {
    interp eval $interp {
      package require Eagle
    }
  } result(2)]

  list $code(1) $result(1) $code(2) $result(2)
} -cleanup {
  catch {object dispose $subCommands}
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain subCommands interp
} -constraints {eagle command.object} -match regexp -result {^0\
\d+\.\d+\.\d+\.\d+ 1 \{permission denied: safe interpreter cannot use command\
"package require"\}$}}

###############################################################################

runTest {test executeCallback-1.1 {ExecuteCallback command} -body {
  set interp [interp create]

  set code(1) [catch {
    interp eval $interp {
      set token 0; set result null

      set code [object invoke Eagle._Tests.Default \
          TestAddExecuteCallback "" foo null token result]

      if {$code ne "Ok"} then {
        error [getStringFromObjectHandle $result]
      }
    }
  } result(1)]

  set code(2) [catch {
    interp eval $interp {
      foo set x 1
    }
  } result(2)]

  set code(3) [catch {
    interp eval $interp {
      set x
    }
  } result(3)]

  list $code(1) $result(1) $code(2) $result(2) $code(3) $result(3)
} -cleanup {
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain interp
} -constraints {eagle command.object\
Eagle._Tests.Default.TestAddExecuteCallback\
Eagle._Tests.Default.TestExecuteCallback1} -result {0 {} 0 1 0 1}}

###############################################################################

runTest {test executeCallback-1.2 {ExecuteCallback sub-command} -body {
  set interp [interp create]
  set command [getCommand $interp package false]

  interp shareobject $interp $command
  interp set $interp command $command

  set code(1) [catch {
    interp eval $interp {
      set token 0; set result null

      set code [object invoke Eagle._Tests.Default \
          TestAddExecuteCallback "" foo $command null token result]

      if {$code ne "Ok"} then {
        error [getStringFromObjectHandle $result]
      }
    }
  } result(1)]

  set code(2) [catch {
    interp eval $interp {
      package foo set x 2
    }
  } result(2)]

  set code(3) [catch {
    interp eval $interp {
      set x
    }
  } result(3)]

  list $code(1) $result(1) $code(2) $result(2) $code(3) $result(3)
} -cleanup {
  catch {object dispose $command}
  catch {interp delete $interp}

  unset -nocomplain result code
  unset -nocomplain command interp
} -constraints {eagle command.object\
Eagle._Tests.Default.TestAddExecuteCallback\
Eagle._Tests.Default.TestExecuteCallback2} -result {0 {} 0 2 0 2}}

###############################################################################

if {[isEagle]} then {
  rename getSubCommands ""
  rename getCommand ""
}

###############################################################################

source [file join [file normalize [file dirname [info script]]] epilogue.eagle]
